## LAB17-1. Создание запланированных задач

#### 1. Выполнение запланированных задач с помощью cron 

1. Чтобы получить представление о содержимом файла конфигурации /etc/crontab введите
```bash
cat /etc/crontab
```

2. Введите crontab -e. Это открывает интерфейс редактора, который по умолчанию используется vi. Добавьте следующую строку:
```bash
0 2 * * 1-5 logger message from root
```

3. Используйте команду `vi: wq!` Что бы закрыть сеанс редактирования и записать изменения.

4. Перейдитее в директорию **/etc/cron.hourly**. В этом каталоге создайте файл сценария с именем **eachhour**, который содержит следующую строку:
```console
logger This message is written at $(date)
```

5. Сделайте скрипт исполняемым;
```bash
chmod +x eachhour
```
если вы не сделаете его исполняемым, он не будет работать.

6. Войдите в каталог **/etc/cron.d** и в этом каталоге создавайте файл с именем **eachhour**. Поместите в файл следующее содержимое:
```console
11 * * * * root logger This message is written from /etc/cron.d
```

7. Сохраните изменения в файле конфигурации и перейдите к следующему разделу. (Для оптимального эффекта выполните шаг 8 через пару часов.) Или скорректируйте запуск заданий на ближайшее для вас время.

8. Прочтите сообщения журнала, чтобы проверить правильность работы cron.
```bash
grep written /var/log/messages
```
>![Screenshot](../img/scr.png)
***Cделайте скриншот экрана c результатом выполнения задания для отправки отчета.***

#### 2. Планирование заданий с помощью at

9. Введите
```bash
systemctl status atd.
```

```console
● atd.service - Deferred execution scheduler
     Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled; preset: enabled)
     Active: active (running) since Wed 2023-04-26 11:35:05 MSK; 3 weeks 1 day ago
       Docs: man:atd(8)
   Main PID: 1371 (atd)
      Tasks: 1 (limit: 4633)
     Memory: 336.0K
        CPU: 436ms
     CGroup: /system.slice/atd.service
             └─1371 /usr/sbin/atd -f
```
В строке, которая начинается с **Loaded: loaded**  должна показать вам, что служба в настоящее время загружена и включена, что означает, что она готова начать получать задания.

10. Введите `at 15:00` (или замените на любое время, близкое к тому времени, когда вы работаете над этим упражнением)

11. Введите `logger message from at`. Нажмите **Ctrl-D**, чтобы закрыть оболочку **at**.

12. Введите `atq`, чтобы убедиться, что задание действительно запланировано.

#### 3. Планирование заданий с помощью systemd.timer

13. Создайте скрипт в домашнем каталоге пользователя **root**, который в одной строке выводит текущую дату и количество свободной оперативной памяти
```bash
#!/bin/bash
/bin/echo -n $(date)
free -h | awk '/^Mem/{print "\t" $4}'
```
14. Сделайте этот скрипт исполняемым.

15. Создайте юнит таймера
```bash
sudo systemctl --force edit mem_mon.timer --full
```
со следующим содержимым
```conf
[Unit]
Description= start mem monitor

[Timer]
OnCalendar=*:00/2:00
AccuracySec=1us

[Install]
WantedBy=timers.target
```

16. Создайте службу автозапуска
```bash
sudo systemctl --force edit mem_mon.service --full
```
со следующим содержимым
```conf
[Unit]
Description= free mem monitor

[Service]
Type=oneshot
ExecStart=/root/mem.sh

[Install]
WantedBy=multi-user.target
```
> Здесь в параметре **ExecStart** указано имя скрипта, который вы создали ранее в пункте 13.

17. Запустите юнит таймера:
```bash
sudo systemctl start mem_mon.timer
```

18. Проверьте работу таймера в журнале: sudo journalctl -xe
>![Screenshot](../img/scr.png)
***Cделайте скриншот экрана c результатом выполнения задания для отправки отчета.***

19. Запустите просмотр systemd журнала в реальном времени
```bash
sudo journalctl -f
```
В случае появления ошибки подобной той, что приведена ниже, выполните рекомендации по настройке безопасности SELinux (возможно это прийдется сделать несколько раз).
```console
мая 18 19:40:09 voitelev2.test.local setroubleshoot[119683]: SELinux запрещает (ndmsg.sh) доступ execute к файл mem.sh. Для выполнения всех сообщений SELinux: sealert -l 8df12a9d-dd86-46d9-9794-8317a47c3424
мая 18 19:40:10 voitelev2.test.local setroubleshoot[119683]: SELinux запрещает (ndmsg.sh) доступ execute к файл mem.sh.

*****  Модуль catchall предлагает (точность 100.)  ***************************

Если вы считаете, что (ndmsg.sh) должно быть разрешено execute доступ к mem.sh file по умолчанию.
То рекомендуется создать отчет об ошибке.
Чтобы разрешить доступ, можно создать локальный модуль политики.
Сделать
разрешить этот доступ сейчас, выполнив:
# ausearch -c '(ndmsg.sh)' --raw | audit2allow -M my-ndmsgsh
# semodule -X 300 -i my-ndmsgsh.pp
```

20. Снова запустите просмотр systemd журнала в реальном времени, добейтесь того чтобы ошибки SELinux больше не было.
```bash
sudo journalctl -f
```

21. Как сделать так, чтобы данные были записаны в файл **/var/log/mem_mon.log**?

#### 4. Самостоятельная работа
22. Создайте задание cron, которое будет выполнять обновление всего программного обеспечения на вашем компьютере каждый вечер в 23:00.

23. Запланируйте единоразово перезагрузку компьютера в 3 часа утра завтра.

24. Выведите на экран информацию о запланированных задачах в пункте 22 и 23, чтобы можно было сформировать скриншот с отчетом о найденом решении
>![Screenshot](../img/scr.png)
***Cделайте скриншот экрана c результатом выполнения задания для отправки отчета.***
